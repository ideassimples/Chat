"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = runAll;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _path = require("path");

var _minimatch = require("minimatch");

var _promise = require("./promise");

var _promise2 = _interopRequireDefault(_promise);

var _runTask = require("./run-task");

var _runTask2 = _interopRequireDefault(_runTask);

//------------------------------------------------------------------------------
function toArray(x) {
    if (x == null) {
        return [];
    }
    return Array.isArray(x) ? x : [x];
}

//------------------------------------------------------------------------------
function readTaskList() {
    try {
        var packageJsonPath = (0, _path.join)(process.cwd(), "package.json");
        var packageJson = require(packageJsonPath);
        var scripts = packageJson && packageJson.scripts;
        if (typeof scripts === "object" && Array.isArray(scripts) === false) {
            return Object.keys(scripts);
        }
    } catch (err) {
        console.error("ERROR:", err.message); // eslint-disable-line no-console
    }

    return null;
}

//------------------------------------------------------------------------------
var COLON_OR_SLASH = /[:\/]/g;
var CONVERT_MAP = { ":": "/", "/": ":" };

function swapColonAndSlash(s) {
    return s.replace(COLON_OR_SLASH, function (matched) {
        return CONVERT_MAP[matched];
    });
}

function filterTasks(taskList, patterns) {
    // Replace ":" to "/", in order to use as separator in minimatch.
    var filters = patterns.map(function (pattern) {
        // Separate arguments.
        var trimmed = pattern.trim();
        var spacePos = trimmed.indexOf(" ");
        var task = spacePos < 0 ? trimmed : trimmed.slice(0, spacePos);
        var args = spacePos < 0 ? "" : trimmed.slice(spacePos);
        var matcher = new _minimatch.Minimatch(swapColonAndSlash(task));
        var match = matcher.match.bind(matcher);

        return { match: match, task: task, args: args, pattern: pattern };
    });
    var candidates = taskList.map(swapColonAndSlash);

    var retv = [];
    var sourceMap = Object.create(null);
    function addToRetv(command, pattern) {
        var source = sourceMap[command] || (sourceMap[command] = []);
        if (source.length === 0 || source.indexOf(pattern) !== -1) {
            retv.push(command);
        }
        source.push(pattern);
    }

    // Take tasks while keep the order of patterns.
    filters.forEach(function (filter) {
        var found = false;

        candidates.forEach(function (task) {
            if (filter.match(task)) {
                found = true;
                addToRetv(swapColonAndSlash(task) + filter.args, filter.pattern);
            }
        });

        // Built-in tasks should be allowed.
        if (!found && (filter.task === "restart" || filter.task === "env")) {
            addToRetv(filter.pattern, filter.pattern);
        }
    });

    return retv;
}

//------------------------------------------------------------------------------
function runAllSequencially(tasks, stdin, stdout, stderr) {
    var currentPromise = null;
    var aborted = false;
    var resultPromise = tasks.reduce(function (prevPromise, task) {
        return prevPromise.then(function () {
            if (aborted) {
                return undefined;
            }

            currentPromise = (0, _runTask2["default"])(task, stdin, stdout, stderr);
            return currentPromise.then(function (item) {
                currentPromise = null;
                if (item.code !== 0 && item.code != null) {
                    throw new Error(item.task + ": None-Zero Exit(" + item.code + ");");
                }
            });
        });
    }, _promise2["default"].resolve());

    // Define abort method.
    resultPromise.abort = function abort() {
        aborted = true;
        if (currentPromise != null) {
            currentPromise.kill();
        }
    };

    return resultPromise;
}

//------------------------------------------------------------------------------
function runAllInParallel(tasks, stdin, stdout, stderr) {
    // When one of tasks exited with non-zero, kill all tasks.
    // And wait for all tasks exit.
    var nonZeroExited = null;
    var taskPromises = tasks.map(function (task) {
        return (0, _runTask2["default"])(task, stdin, stdout, stderr);
    });
    var parallelPromise = _promise2["default"].all(taskPromises.map(function (p) {
        return p.then(function (item) {
            if (item.code !== 0 && item.code != null) {
                nonZeroExited = nonZeroExited || item;
                taskPromises.forEach(function (t) {
                    t.kill();
                });
            }
        });
    }));
    parallelPromise["catch"](function () {
        taskPromises.forEach(function (t) {
            t.kill();
        });
    });

    // Make fail if there are tasks that exited non-zero.
    var resultPromise = parallelPromise.then(function () {
        if (nonZeroExited != null) {
            throw new Error(nonZeroExited.task + ": None-Zero Exit(" + nonZeroExited.code + ");");
        }
    });

    // Define abort method.
    resultPromise.abort = function abort() {
        taskPromises.forEach(function (t) {
            t.kill();
        });
    };

    return resultPromise;
}

//------------------------------------------------------------------------------

function runAll(patternOrPatterns) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var patterns = toArray(patternOrPatterns);
    if (patterns.length === 0) {
        return _promise2["default"].resolve(null);
    }

    var _options$parallel = options.parallel;
    var parallel = _options$parallel === undefined ? false : _options$parallel;
    var _options$stdin = options.stdin;
    var stdin = _options$stdin === undefined ? null : _options$stdin;
    var _options$stdout = options.stdout;
    var stdout = _options$stdout === undefined ? null : _options$stdout;
    var _options$stderr = options.stderr;
    var stderr = _options$stderr === undefined ? null : _options$stderr;
    var _options$taskList = options.taskList;
    var taskList = _options$taskList === undefined ? readTaskList() : _options$taskList;

    if (Array.isArray(taskList) === false) {
        return _promise2["default"].reject(new Error(options.taskList ? "Invalid TaskList: " + options.taskList :
        /* else */"Not Found: " + (0, _path.join)(process.cwd(), "package.json")));
    }

    var tasks = filterTasks(taskList, patterns);
    if (tasks.length === 0) {
        return _promise2["default"].reject(new Error("Matched tasks not found: " + patterns.join(", ")));
    }

    return parallel ? runAllInParallel(tasks, stdin, stdout, stderr) :
    /* else */runAllSequencially(tasks, stdin, stdout, stderr);
}

module.exports = exports["default"];